\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{graphicx}

%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%
\begin{document}
%
\title{Self-loops in social networks: behavior of eigenvector centrality\thanks{This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project
PID2020-115570GB-C22 (DemocratAI::UGR).}}

\author{JJ Merelo\inst{1}\orcidID{0000-0002-1385-9741} and M. Cristina Molinari\inst{2}}
%
\authorrunning{Merelo, Molinari}

\institute{Department of Computer Engineering, Automatics and Robotics and CITIC University of Granada, Granada, Spain
\email{jmerelo@ugr.es} \and
Dipartimento di Economia, Ca' Foscari University of Venice, Venice, ITALY
}
%
\maketitle
%
\begin{abstract}
Centrality measures are an essential tool in understanding complex networks, since they give researcher insights on the role the different nodes/actors play in them. Among them, eigenvector centrality is a principled approach to these measures, using a mathematical operation on the connection matrix. This connection  matrix includes connections from an actor to itself (the diagonal); however, as is the case with most centrality measures, this fact is seldom used in social studies to compute the standing or influence of one node over the rest. In this paper we will analyze the difference in EV centrality with or without these self connections or self-loops and how the change depends on the actual value of these self-loops. Finally, we will characterize in which cases it is effective to drop the self-loops, if any, and what kind of information will it give us on the nature and dynamics of the network.

\keywords{Complex networks  \and Social  networks \and Graph Theory \and Eigenvector centrality}
\end{abstract}
%

\section{Introduction}

Eigenvector centrality \cite{doi:10.1080/0022250X.1972.9989806} measures how an actor in a network or graph influences other actor by computing the eigenvalues of the adjacency or connectivity matrix, that has as components the weight of the connection of every agent to all the others, including itself. It is a centrality measure because, along with other such measures (such as betweenness or degree centrality \cite{Rodrigues2019}), it is a micro-level assessment of the power or influence of a node within a network through the analysis of its connections. It has been used extensively in social network analysis \cite{gooddoge,DBLP:journals/corr/abs-1108-0261,merelo2007bce}; but also in other fields, such as biology \cite{horstmeyer2020predicting}, economics \cite{colleganza}, or even in the analysis of the spread of opinions in internet forums during the COVID-19 pandemic \cite{computation11050103}. In its widespread use it is not very different from other centrality measures; however, unlike them, it considers the whole network \cite{BONACICH2007555} taking into account weights (including negative ones) for the computation of the value for a single node; and, more importantly for the purposes of this paper, that includes the connections of a node to itself, or self-loops. 

As a matter of fact, many complex networks, including social networks, include links from one actor/agent to itself; we can find them in commuting networks \cite{he2020demarcating}, where self-loops would indicate trips that start and end in the same city, county or state; in family networks \cite{he2020demarcating}, with self-loops indicating marriage between members of the same (extended) family; opinion networks \cite{computation11050103}, where they would indicate interaction among members of the same group; sport teams transfer networks \cite{gursakal2020comparison}, indicating transfers between teams in the same country; when freight traffic networks \cite{iyengar2012power} are analyzed at a regional level, self-loops would represent shipments that start and end in different parts of the region; commercial networks \cite{colleganza} where self-loops indicate a contract between members of the same family, or even biological networks \cite{horstmeyer2020predicting}, where self-loops could indicate auto-trophic (members of a species feeding on other members) or auto-catalytic (reactive agents catalyzing reactions where they participate).

The main issue and the one we are trying to over come in this paper, is that when centrality analysis are performed on these networks, most centrality measures cannot work with them, so in most cases they are dropped \cite{computation11050103,colleganzagooddoge}. Even in the case of measurements that work on the connection matrix, like the aforementioned eigenvector centrality, self-loops are dropped mainly to work on an uniform set of data, that is, not use a connection matrix with diagonal values (for EV centrality) and other without (for other measures). In the cases where it does not have a clear interpretation there are good reasons to work that: betweenness centrality \cite{freeman1977set}, for instance, models how one node is needed to transmit information to other parts of the network; how often it transmits information to itself cannot easily be accommodated within this framework, and would be simply ignored when computing the geodesics from which this measure is computed.

That is not the case for EV centrality, which does in fact use self-loops to compute the eigenvalues that are presented as the EV centrality measure. And these intra-links can, however, give us better insights on the dynamics of a social network, and should probably be taken into account. So far, however, there has been little analysis on what is the actual effect of considering these intra-links for computing the eigenvector centrality \cite{BONACICH2007555} in social networks. This paper will try, using well-chosen examples, what is that effect and how it could help to better understand social systems.

The rest of the paper is organized as follows: next we will be describing the state of the art, to proceed to describe the datasets and the experiments performed in Section \ref{sec:exp}. We will then discuss the results and conclude with or conclusion and future lines of work.

\section{State of the art}

The main motivation behind this paper is to shed a bit of light on the use of self-loops in social network analysis, mainly because it has been used so rarely in the past. Some papers acknowledge its importance in the propagation of information in social networks \cite{9688320}, with self-loops representing simply re-posts of some content previously created by the same person; other papers, however \cite{computation11050103} dealing with the same subject, explicitly do not use them, thus missing a good amount of the dynamics created by these self loops. In other opinion formation papers \cite{salehi2014empathetic} self-loops represent the amount of attention a person pays to its own opinion as opposed to others. In general, even theoretical models of the spread of information in social networks \cite{CHIERICHETTI20112602} include self-loops.

The main issue is that the application of self loops is mainly limited to models of the spread of information, and not to the analysis of the network itself. This why we have made it the main focus of this paper.

\section{Experiments}
\label{sec:exp}

We will be using two datasets to perform the experiments. The first one is the {\em Venetian matrimonial} dataset \cite{colleganza}, a social network of the families of the Republic of Venice from the XIV to the XIX century\footnote{It also includes some marriages without a date}, as well as a dataset of freight traffic among the states of the United States of America extracted from their open data portal \cite{southworth2018freight}. These will be examined in turn in the next subsections.

\subsection{Analyzing the Venetian matrimonial dataset}

<<setup, echo=F,message=F>>=
library(igraph)
library(knitr)
library(stringr)
library(kableExtra)
tablify <- function( graph, column ) {
  m.table <- data.frame( Family=V(graph)$name, degree=vertex_attr(graph,column) )
  names(m.table)[names(m.table) == "degree"] <- column
  return( m.table[ order(m.table[[column]],decreasing = T),] )
}


load("data/venice-marriages.Rda")
all.marriages <- marriages.raw[ marriages.raw$wife_familyname_std != '',] # Eliminates those that are not noble

# Use self-loops
all.marriages.sn <- graph.data.frame(data.frame(all.marriages$husband_familyname_std,all.marriages$wife_familyname_std),directed=F)
V(all.marriages.sn)$eigen <-  unname(unlist(eigen_centrality(all.marriages.sn)$vector))
all.m.eigen <- tablify( all.marriages.sn, "eigen")
all.m.eigen$rank <- 1:nrow(all.m.eigen)
top.ev.all.eigen <- all.m.eigen %>% head(.,10)

# Eliminate self-loops
marriages <- all.marriages[ all.marriages$husband_familyname_std != all.marriages$wife_familyname_std,]
marriages.sn <- graph.data.frame(data.frame(marriages$husband_familyname_std,marriages$wife_familyname_std),directed=F)
V(marriages.sn)$eigen <-  unname(unlist(eigen_centrality(marriages.sn)$vector))
m.eigen <- tablify( marriages.sn, "eigen")
m.eigen$rank <- 1:nrow(m.eigen)
top.ev.eigen <- m.eigen %>% head(.,10)
@

This dataset was published by Puga and Treffler as support for their paper \cite{colleganza}. This dataset is composed of marriages performed in the Republic of Venice (and successor polities during the late XVIII and XIX century) where the groom is a noble \footnote{Since the dataset includes some marriages that happened after the fall of the Republic in 1796, the concept of "noble" in this case corresponds to families that were considered noble {\em during the existence of said Republic}; during French and Austrian control, as well as during the brief period of the Republic of San Marco, those nobiliary titles no longer had any standing; however, the original dataset included them and there was no good reason to eliminate them}, registered with the {\em Avvogaria del Comune} of the Republic. Families (called {\em casate} in the original Venetian and Italian) were the political and social unit in the republic \cite{pullan1999three,romano2014limits}. which explains the interest these datasets have for insights into the history of the republic.

From this dataset, those where the bride did not belong to a patrician family have been eliminated\footnote{There were many restrictions to this kind of marriage, but they occurred with regularity, at least until the so-called "Second Serrata" \cite{second:serrata}, during the XV century; in this case, however, we eliminate them because they are irrelevant to the main point of the paper}.

This dataset has been chosen because it includes a good number of intra-family marriages, as well as because it has been studied extensively by Puga and Treffler in their paper, providing a basis for the comparison of results.
%
<<intra.marriages, echo=F,message=F>>=
library(dplyr)
all.marriages %>% group_by(str_sub(all.marriages$year,1,2)) %>% summarise(intra.marriages=sum(wife_familyname_std==husband_familyname_std),total.marriages = n()) %>% mutate(percentage = 100 * intra.marriages/total.marriages) -> intra.marriages.table

intra.marriages.table %>% rename(century.years="str_sub(all.marriages$year, 1, 2)") -> intra.marriages.table
intra.marriages.table %>% mutate(century = as.roman(as.numeric(century.years)+1)) %>% select(-1) %>% relocate(century,.before=1) -> intra.marriages.table

kable(intra.marriages.table,format="latex",digits=2,caption="Intra-family marriages per century \\protect\\label{tab:century:marriages}", col.names=c("Century","Intra-family marriages","Total marriages","Percentage")) %>% kable_styling(latex_options = c("striped", "hold_position"), full_width = F, position = "left")

marriages.self <- marriages.raw[ marriages.raw$husband_familyname_std == marriages.raw$wife_familyname_std,]
sorted.marriages.self <- marriages.self %>% count(wife_familyname_std, sort=T)
intra.marriages <- unique(marriages.self$wife_familyname_std)

top.intra.marriages <-  sorted.marriages.self %>% head(.,10)

tabled.top.eigen <- data.frame(Family.Intra = top.intra.marriages$wife_familyname_std, Marriages=top.intra.marriages$n)
kable(tabled.top.eigen,
      col.names=c("Family", "#Intra-family matrimonies" ),
      caption="Ranking of families according to number of intra-family matrimonies (left). \\protect\\label{tab:top:families}",
      row.names = F, booktabs = T) %>% kable_styling(latex_options = c("striped"))
@

%
The evolution of the absolute  and relative number of intra-family marriages per century is shown in Table \ref{tab:century:marriages}, together with those whose date is not available. These marriages are not evenly distributed per family; the top 10 families according to number of intra-family marriages is shown in Table \ref{tab:top:families}. This is an example where the number of self-loops is not excessive, although it is certainly significant, hovering around a few percentage points per century for an amount of \Sexpr{sum(intra.marriages.table$intra.marriages)} intra-family marriages (self-loops) over \Sexpr{sum(intra.marriages.table$total.marriages)} total.

%

<<centuries, echo=F,message=F>>=

tabled.top.eigen <- data.frame(Family.Intra = top.intra.marriages$wife_familyname_std, Marriages=top.intra.marriages$n, Family = top.ev.eigen$Family, EV = top.ev.eigen$eigen, Family.Self=top.ev.all.eigen$Family, EV.self = top.ev.all.eigen$eigen)
kable(tabled.top.eigen,
      col.names=c("Family", "#Intra-family matrimonies", "Family", "EV","Family","EV + self-loops" ),
      caption="Ranking of families according to number of intra-family matrimonies (left) and EV, with (right) or without (center) self-loops. \\protect\\label{tab:top:ev}",
      row.names = F, booktabs = T) %>% kable_styling(latex_options = c("striped")) %>% column_spec(2, border_right=T) %>% column_spec(3, border_left = T ) %>% column_spec(4, border_right=T) %>% column_spec(5, border_left = T )
library(ggplot2)
# Extract marriages taking place in 14xx and 15xx
marriages.XV <- all.marriages[ !is.na(all.marriages$year) & all.marriages$year>=1400 & all.marriages$year < 1500,]
marriages.XVI <- all.marriages[ !is.na(all.marriages$year) & all.marriages$year>=1500 & all.marriages$year < 1600,]
marriages.XV.sn <- graph.data.frame(data.frame(marriages.XV$husband_familyname_std,marriages.XV$wife_familyname_std),directed=F)
V(marriages.XV.sn)$eigen <-  unname(unlist(eigen_centrality(marriages.XV.sn)$vector))
marriages.XVI.sn <- graph.data.frame(data.frame(marriages.XVI$husband_familyname_std,marriages.XVI$wife_familyname_std),directed=F)
V(marriages.XVI.sn)$eigen <-  unname(unlist(eigen_centrality(marriages.XVI.sn)$vector))

# Create a data frame with nodes common in marriages.XVI.sn and marriages.XV.sn and their corresponding eigen centrality

common.nodes <- intersect( V(marriages.XVI.sn)$name, V(marriages.XV.sn)$name )
common.nodes.eigen <- data.frame( Family=common.nodes, XV.eigen=V(marriages.XV.sn)[common.nodes]$eigen, XVI.eigen=V(marriages.XVI.sn)[common.nodes]$eigen )
ggplot( common.nodes.eigen, aes(x=XV.eigen,y=XVI.eigen)) + geom_point()

# fit a linear model to common.nodes.eigen$XVi.eigen ~ common.nodes.eigen$XV.eigen
marriages.fit <- lm( XVI.eigen ~ XV.eigen, data=common.nodes.eigen )

# plot the fit
ggplot( common.nodes.eigen, aes(x=XV.eigen,y=XVI.eigen)) + geom_point() + geom_abline(intercept=marriages.fit$coefficients[1],slope=marriages.fit$coefficients[2])

# Do the same for marriages without self-loops
marriages.XV.no.selfloops <- marriages.XV[ marriages.XV$husband_familyname_std != marriages.XV$wife_familyname_std,]
marriages.XVI.no.selfloops <- marriages.XVI[ marriages.XVI$husband_familyname_std != marriages.XVI$wife_familyname_std,]
marriages.XV.sn.no.selfloops <- graph.data.frame(data.frame(marriages.XV.no.selfloops$husband_familyname_std,marriages.XV.no.selfloops$wife_familyname_std),directed=F)
V(marriages.XV.sn.no.selfloops)$eigen <-  unname(unlist(eigen_centrality(marriages.XV.sn.no.selfloops)$vector))
marriages.XVI.sn.no.selfloops <- graph.data.frame(data.frame(marriages.XVI.no.selfloops$husband_familyname_std,marriages.XVI.no.selfloops$wife_familyname_std),directed=F)
V(marriages.XVI.sn.no.selfloops)$eigen <-  unname(unlist(eigen_centrality(marriages.XVI.sn.no.selfloops)$vector))

# Create a data frame with nodes common in marriages.XVI.sn and marriages.XV.sn and their corresponding eigen centrality

common.nodes.no.selfloops <- intersect( V(marriages.XVI.sn.no.selfloops)$name, V(marriages.XV.sn.no.selfloops)$name )
common.nodes.eigen.no.selfloops <- data.frame( Family=common.nodes.no.selfloops, XV.eigen=V(marriages.XV.sn.no.selfloops)[common.nodes.no.selfloops]$eigen, XVI.eigen=V(marriages.XVI.sn.no.selfloops)[common.nodes.no.selfloops]$eigen )
ggplot( common.nodes.eigen.no.selfloops, aes(x=XV.eigen,y=XVI.eigen)) + geom_point()

marriages.no.selfloops.fit <- lm( XVI.eigen ~ XV.eigen, data=common.nodes.eigen.no.selfloops )

# plot the fit

ggplot( common.nodes.eigen.no.selfloops, aes(x=XV.eigen,y=XVI.eigen)) + geom_point() + geom_abline(intercept=marriages.no.selfloops.fit$coefficients[1],slope=marriages.no.selfloops.fit$coefficients[2])





# merge m.eigen and all.m.eigen to get the rank of the families
m.ranks <- merge( m.eigen, all.m.eigen, by="Family", suffixes=c(".no.selfloops",".all") )


# Ditto for US freight traffic
load("data/freight-traffic-agg.RData")
all.freight <- freight.traffic.agg[ freight.traffic.agg$Year == 2021,]
edgelist <- data.frame(V1=all.freight$Origin.State,V2=all.freight$Dest.State,weight=all.freight$sum)
all.freight.sn <- graph_from_data_frame(edgelist)
V(all.freight.sn)$eigen <-  unname(unlist(eigen_centrality(all.freight.sn)$vector))
all.f.eigen <- tablify( all.freight.sn, "eigen")
top.ev.all.f.eigen <- all.f.eigen %>% head(.,10)

# Now without self-loops
freight <- all.freight[ all.freight$Origin.State != all.freight$Dest.State,]
edgelist.noselfloops <- data.frame(V1=freight$Origin.State,V2=freight$Dest.State,weight=freight$sum)
freight.sn <- graph_from_data_frame(edgelist.noselfloops)
V(freight.sn)$eigen <-  unname(unlist(eigen_centrality(freight.sn)$vector))
f.eigen <- tablify( freight.sn, "eigen")
top.ev.f.eigen <- f.eigen %>% head(.,10)


library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(ggthemes)


@

This dataset has been transformed into a graph by eliminating self-loops (as usual), or leaving them, using undirected edges joining the two families of the partners in every marriage; the edge is weighted with the number of marriages between the families in the nodes; eigenvector centrality has then been computed for the two resulting graphs. A ranking of the top families according to their EV centrality is shown in Table \ref{tab:top:ev} (center and rightmost columns).

Looking at the leftmost and center group of columns, we can wee that there seems to be certain correlation between the number of intra-family marriages and the EV centrality, even if we do not include it in the computation. Six out of then families are the same, and the first three: Contarini, Morosini, Corner also appear in the same order. This might indicate either a common cause (size of the family, for instance) or a cause-effect. Including self-loops in the computation we see that there are small, but significant, variations: The Dolfins and Giustinians change their order in the ranking, plus the Loredan family is dropped and substituted by the Pisani family\footnote{The Pisani family is certainly more "central" than the Loredan, at least looking at the number of nobles in important offices}. We can also see that the difference between the first and second has doubled, and that, in general, the value of the normalized EV centrality has also decreased.

<<charts, echo=F, fig.show="hold", out.width="50%",message=F, fig.cap="(Left) EV centrality considering self-loops (x axis) or not (y axis). The size of the dot and color signal the number of intra-family marriages. (Right) Number of intra-family marriages vs. percent increment of EV when self-loops are not computed. \\protect\\label{fig:plots}">>=
all.names <- unique( c( marriages.raw$wife_familyname_std, marriages.raw$husband_familyname_std))
all.marriages <- marriages.raw %>% select(husband_familyname_std,wife_familyname_std) %>% rowid_to_column() %>% pivot_longer(-rowid) %>% group_by(value) %>% summarise(n = n_distinct(rowid)) %>% arrange(desc(n))
marriages.table <- left_join(all.marriages,sorted.marriages.self,by=c("value" = "wife_familyname_std"))
marriages.table$intra.marriages.rate <- marriages.table$n.y / marriages.table$n.x

marriages.summary <- data.frame(family=intra.marriages, EV.with.self=sapply( intra.marriages, function(x) V(all.marriages.sn)[[x]]$eigen ), EV.no.self=sapply( intra.marriages, function(x) V(marriages.sn)[[x]]$eigen ), intra.marriages=sapply( intra.marriages, function(x) sorted.marriages.self[sorted.marriages.self$wife_familyname_std ==x,]$n ))
ggplot(marriages.summary, aes(x=EV.with.self,y=EV.no.self, color=intra.marriages, size=intra.marriages))+geom_point()+geom_abline(intercept=0,slope=1,linetype="dashed",color="red")+scale_x_log10()+scale_y_log10()
marriages.summary$diff <- (marriages.summary$EV.no.self - marriages.summary$EV.with.self)/marriages.summary$EV.no.self
ggplot(marriages.summary, aes(x=intra.marriages,y=diff))+geom_point()+theme_fivethirtyeight()

ggplot(m.ranks, aes(x=rank.no.selfloops,y=rank.all))+geom_point()+geom_abline(intercept=0,slope=1,linetype="dashed",color="red")
@

This is why in Figure \ref{fig:plots} we have analyzed the differences between the EV values with or without loops for every node. The left hand side of that Figure plots the values with self-loops vs. those without in a log scale, showing all values over the $x=y$ line; all values are increased. Looking at the colors and sizes, we can see that the smaller the size (number of marriages), the bigger the increase in value; that is, more intra-family marriages make the inclusion of self-loops decrease \emph{less} the EV centrality. However, this is due in this case to the fact that what is actually increased is the difference between the family with EV 1 (the Contarinis) and the rest, so we can look at this result from the other side: the presence of a family with a high value in the diagonal of the connection matrix increases its EV centrality much more than that of the rest of the nodes/families. The right hand side of Figure \ref{fig:plots} certainly shows that there is a relationship between the number of intra-family weddings and the change, and that this relationship is systematic. At any rate, what this chart reveals is that, as should be expected, the value of intra-family marriages/self-loops in the computation of EV centrality certainly gives us better insights on the dynamics of the social network.

\section{Conclusions}

We can conclude from this that, in general, the inclusion of self-loops in other centrality measures, such as page-rank or betweenness centrality, would help us understand better social networks where those measurements explain better its dynamics; however, this will need a modification of the algorithms used to compute them, which is left as a future line of work. In order to be comprehensive, too, it would be interesting to see the relationship between the slope of the model shown in Figure \ref{fig:charts} and the relationship between the number of self-loops for all actors involved. Finally, investigating other social networks with the same characteristics would help us generalize these results and thus recommend to \emph{never} eliminate self-loops in the analysis of social networks where they exist.

The most important line of work, however, is to check against some external measurement (number and importance of positions reached by a family, for instance, in line with \cite{Telek2017MarryingTR}) which version of the EV centrality would be a better match, thus proving that self-loops/diagonal values in the connection matrix go beyond mere mathematical artifacts to have a precise and grounded interpretation; once that is proved, it would pave the way to an extension of the employment of self-loops in some way in other centrality values such as betweenness centrality.

\bibliographystyle{splncs04}
\bibliography{venice,self-loops}

\end{document}
