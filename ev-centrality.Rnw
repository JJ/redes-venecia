\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{graphicx}

%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%
\begin{document}
%
\title{Self-loops in social networks: behavior of eigenvector centrality\thanks{This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project
PID2020-115570GB-C22 (DemocratAI::UGR).}}

\author{JJ Merelo\inst{1}\orcidID{0000-0002-1385-9741} and M. Cristina Molinari\inst{2}}
%
\authorrunning{Merelo, Molinari}

\institute{Department of Computer Engineering, Automatics and Robotics and CITIC University of Granada, Granada, Spain
\email{jmerelo@ugr.es} \and
Dipartimento di Economia, Ca' Foscari University of Venice, Venice, ITALY
}
%
\maketitle
%
\begin{abstract}
Centrality measures are an essential tool in understanding complex networks, since they give researcher insights on the role the different nodes/actors play in them. Among them, eigenvector centrality is a principled approach to these measures, using a mathematical operation on the connection matrix. This connection  matrix includes connections from an actor to itself (the diagonal); however, as is the case with most centrality measures, this fact is seldom used in social studies to compute the standing or influence of one node over the rest. In this paper we will analyze the difference in EV centrality with or without these self connections or self-loops and how the change depends on the actual value of these self-loops. Finally, we will characterize in which cases it is effective to drop the self-loops, if any, and what kind of information will it give us on the nature and dynamics of the network.

\keywords{Complex networks  \and Social  networks \and Graph Theory \and Eigenvector centrality}
\end{abstract}
%

\section{Introduction}

Eigenvector centrality \cite{doi:10.1080/0022250X.1972.9989806} measures how an actor in a network or graph influences other actor by computing the eigenvalues of the adjacency or connectivity matrix, that has as components the weight of the connection of every agent to all the others, including itself. It is a centrality measure because, along with other such measures (such as betweenness or degree centrality \cite{Rodrigues2019}), it is a micro-level assessment of the power or influence of a node within a network through the analysis of its connections. It has been used extensively in social network analysis \cite{gooddoge,
Unlike other measurements, however, it considers the whole network \cite{BONACICH2007555}, can take into account all weights (including negative ones), and more importantly for the purposes of this paper, it takes into account the connections of a node to itself, or self-loops. 

Many complex networks, including social networks, include links from one actor/agent to itself; we can find them in commuting networks \cite{he2020demarcating}, where self-loops would indicate trips that start and end in the same city, county or state; in family networks \cite{he2020demarcating}, with self-loops indicating marriage between members of the same (extended) family; opinion networks \cite{computation11050103}, where they would indicate interaction among members of the same group; sport teams transfer networks \cite{gursakal2020comparison}, indicating transfers between teams in the same country; when freight traffic networks \cite{iyengar2012power} are analyzed at a regional level, self-loops would represent shipments that start and end in different parts of the region; commercial networks \cite{colleganza} where self-loops indicate a contract between members of the same family, or even biological networks \cite{horstmeyer2020predicting}, where self-loops could indicate auto-trophic (members of a species feeding on other members) or auto-catalytic (reactive agents catalyzing reactions where they participate).

When analysis is performed on these networks, however, most centrality measures cannot work with them, so in most cases they are dropped \cite{computation11050103}. Even in the case of measurements that work on the connection matrix, like eigenvector centrality, self-loops are dropped mainly to work on an uniform set of data, that is, not use a connection matrix with diagonal values (for EV centrality) and other without (for other measures). At any rate, it is dropped in cases where it does not have a clear interpretation: betweenness centrality, for instance, models how one node is needed to transmit information to other parts of the network; how often it transmits information to itself cannot easily be accommodated within this framework.

These intra-links can, however, give us better insights on the dynamics of a social network, and should probably be taken into account. So far, however, there has been little analysis on what is the actual effect of intra-links on the eigenvector centrality \cite{BONACICH2007555} in social networks. This paper will try, using a well-chosen example, what is that effect and how it will help better understand social systems.

The rest of the paper is organized as follows: next we will be describing the state of the art, to proceed to describe the datasets and the experiments performed in Section \ref{sec:exp}. We will then discuss the results and conclude with or conclusion and future lines of work.

\section{State of the art}


\section{Experiments}
\label{sec:exp}

We will be using the marital network of the Republic of Venice, data published by Puga and Treffler for their paper \cite{colleganza}. This dataset has been chosen because it includes many intra-family marriages; a ranking of the families according to the number of marriages is shown in Table \ref{tab:top:ev} (left). This dataset is composed of marriages where the groom is a noble, registered with the {\em Avvogaria del Comune} of the republic. From this dataset, those where the bride did not belong to a patrician family have been eliminated\footnote{There were many restrictions to this kind of marriage, but they occurred with regularity, at least until the so-called "Second Serrata", during the XV century; in this case, however, we eliminate them because they are irrelevant to the main point of the paper}. The dataset is normalized to include only the family bride and groom belong to.

%
<<setup, echo=F,message=F>>=
library(igraph)
library(knitr)
library(stringr)
library(kableExtra)
tablify <- function( graph, column ) {
  m.table <- data.frame( Family=V(graph)$name, degree=vertex_attr(graph,column) )
  names(m.table)[names(m.table) == "degree"] <- column
  return( m.table[ order(m.table[[column]],decreasing = T),] )
}


load("data/venice-marriages.Rda")
marriages <- marriages.raw[ marriages.raw$wife_familyname_std != '',] # Eliminates those that are not noble

# Use self-loops
all.marriages <- marriages                                    # Keep marriages with intra-family ties
all.marriages.sn <- graph.data.frame(data.frame(all.marriages$husband_familyname_std,all.marriages$wife_familyname_std),directed=F)
V(all.marriages.sn)$eigen <-  unname(unlist(eigen_centrality(all.marriages.sn)$vector))
all.m.eigen <- tablify( all.marriages.sn, "eigen")
top.ev.all.eigen <- all.m.eigen %>% head(.,10)

# Eliminate self-loops
marriages <- marriages[ marriages$husband_familyname_std != marriages$wife_familyname_std,]
marriages.sn <- graph.data.frame(data.frame(marriages$husband_familyname_std,marriages$wife_familyname_std),directed=F)
V(marriages.sn)$eigen <-  unname(unlist(eigen_centrality(marriages.sn)$vector))
m.eigen <- tablify( marriages.sn, "eigen")
top.ev.eigen <- m.eigen %>% head(.,10)

# Ditto for US freight traffic
load("data/freight-traffic-agg.RData")
all.freight <- freight.traffic.agg[ freight.traffic.agg$Year == 2021,]
edgelist <- data.frame(V1=all.freight$Origin.State,V2=all.freight$Dest.State,weight=all.freight$sum)
all.freight.sn <- graph_from_data_frame(edgelist)
V(all.freight.sn)$eigen <-  unname(unlist(eigen_centrality(all.freight.sn)$vector))
all.f.eigen <- tablify( all.freight.sn, "eigen")
top.ev.all.f.eigen <- all.f.eigen %>% head(.,10)

# Now without self-loops
freight <- all.freight[ all.freight$Origin.State != all.freight$Dest.State,]
edgelist.noselfloops <- data.frame(V1=freight$Origin.State,V2=freight$Dest.State,weight=freight$sum)
freight.sn <- graph_from_data_frame(edgelist.noselfloops)
V(freight.sn)$eigen <-  unname(unlist(eigen_centrality(freight.sn)$vector))
f.eigen <- tablify( freight.sn, "eigen")
top.ev.f.eigen <- f.eigen %>% head(.,10)


library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(ggthemes)

marriages.self <- marriages.raw[ marriages.raw$husband_familyname_std == marriages.raw$wife_familyname_std,]
sorted.marriages.self <- marriages.self %>% count(wife_familyname_std, sort=T)
intra.marriages <- unique(marriages.self$wife_familyname_std)

top.intra.marriages <-  sorted.marriages.self %>% head(.,10)

tabled.top.eigen <- data.frame(Family.Intra = top.intra.marriages$wife_familyname_std, Marriages=top.intra.marriages$n, Family = top.ev.eigen$Family, EV = top.ev.eigen$eigen, Family.Self=top.ev.all.eigen$Family, EV.self = top.ev.all.eigen$eigen)
kable(tabled.top.eigen,
      col.names=c("Family", "#Intra-family matrimonies", "Family", "EV","Family","EV + self-loops" ),
      caption="Ranking of families according to number of intra-family matrimonies (left) and EV, with (right) or without (center) self-loops. \\protect\\label{tab:top:ev}",
      row.names = F, booktabs = T) %>% kable_styling(latex_options = c("striped")) %>% column_spec(2, border_right=T) %>% column_spec(3, border_left = T ) %>% column_spec(4, border_right=T) %>% column_spec(5, border_left = T )
@

This dataset has been transformed into a graph by eliminating self-loops (as usual), or leaving them, using undirected edges joining the two families of the partners in every marriage; the edge is weighted with the number of marriages between the families in the nodes; eigenvector centrality has then been computed for the two resulting graphs. A ranking of the top families according to their EV centrality is shown in Table \ref{tab:top:ev} (center and rightmost columns).

Looking at the leftmost and center group of columns, we can wee that there seems to be certain correlation between the number of intra-family marriages and the EV centrality, even if we do not include it in the computation. Six out of then families are the same, and the first three: Contarini, Morosini, Corner also appear in the same order. This might indicate either a common cause (size of the family, for instance) or a cause-effect. Including self-loops in the computation we see that there are small, but significant, variations: The Dolfins and Giustinians change their order in the ranking, plus the Loredan family is dropped and substituted by the Pisani family\footnote{The Pisani family is certainly more "central" than the Loredan, at least looking at the number of nobles in important offices}. We can also see that the difference between the first and second has doubled, and that, in general, the value of the normalized EV centrality has also decreased.

<<charts, echo=F, fig.show="hold", out.width="50%",message=F, fig.cap="(Left) EV centrality considering self-loops (x axis) or not (y axis). The size of the dot and color signal the number of intra-family marriages. (Right) Number of intra-family marriages vs. percent increment of EV when self-loops are not computed. \\protect\\label{fig:plots}">>=
all.names <- unique( c( marriages.raw$wife_familyname_std, marriages.raw$husband_familyname_std))
all.marriages <- marriages.raw %>% select(husband_familyname_std,wife_familyname_std) %>% rowid_to_column() %>% pivot_longer(-rowid) %>% group_by(value) %>% summarise(n = n_distinct(rowid)) %>% arrange(desc(n))
marriages.table <- left_join(all.marriages,sorted.marriages.self,by=c("value" = "wife_familyname_std"))
marriages.table$intra.marriages.rate <- marriages.table$n.y / marriages.table$n.x

marriages.summary <- data.frame(family=intra.marriages, EV.with.self=sapply( intra.marriages, function(x) V(all.marriages.sn)[[x]]$eigen ), EV.no.self=sapply( intra.marriages, function(x) V(marriages.sn)[[x]]$eigen ), intra.marriages=sapply( intra.marriages, function(x) sorted.marriages.self[sorted.marriages.self$wife_familyname_std ==x,]$n ))
ggplot(marriages.summary, aes(x=EV.with.self,y=EV.no.self, color=intra.marriages, size=intra.marriages))+geom_point()+geom_abline(intercept=0,slope=1,linetype="dashed",color="red")+scale_x_log10()+scale_y_log10()
marriages.summary$diff <- (marriages.summary$EV.no.self - marriages.summary$EV.with.self)/marriages.summary$EV.no.self
ggplot(marriages.summary, aes(x=intra.marriages,y=diff))+geom_point()+theme_fivethirtyeight()
@

This is why in Figure \ref{fig:plots} we have analyzed the differences between the EV values with or without loops for every node. The left hand side of that Figure plots the values with self-loops vs. those without in a log scale, showing all values over the $x=y$ line; all values are increased. Looking at the colors and sizes, we can see that the smaller the size (number of marriages), the bigger the increase in value; that is, more intra-family marriages make the inclusion of self-loops decrease \emph{less} the EV centrality. However, this is due in this case to the fact that what is actually increased is the difference between the family with EV 1 (the Contarinis) and the rest, so we can look at this result from the other side: the presence of a family with a high value in the diagonal of the connection matrix increases its EV centrality much more than that of the rest of the nodes/families. The right hand side of Figure \ref{fig:plots} certainly shows that there is a relationship between the number of intra-family weddings and the change, and that this relationship is systematic. At any rate, what this chart reveals is that, as should be expected, the value of intra-family marriages/self-loops in the computation of EV centrality certainly gives us better insights on the dynamics of the social network.

\section{Conclusions}

We can conclude from this that, in general, the inclusion of self-loops in other centrality measures, such as page-rank or betweenness centrality, would help us understand better social networks where those measurements explain better its dynamics; however, this will need a modification of the algorithms used to compute them, which is left as a future line of work. In order to be comprehensive, too, it would be interesting to see the relationship between the slope of the model shown in Figure \ref{fig:charts} and the relationship between the number of self-loops for all actors involved. Finally, investigating other social networks with the same characteristics would help us generalize these results and thus recommend to \emph{never} eliminate self-loops in the analysis of social networks where they exist.

The most important line of work, however, is to check against some external measurement (number and importance of positions reached by a family, for instance, in line with \cite{Telek2017MarryingTR}) which version of the EV centrality would be a better match, thus proving that self-loops/diagonal values in the connection matrix go beyond mere mathematical artifacts to have a precise and grounded interpretation; once that is proved, it would pave the way to an extension of the employment of self-loops in some way in other centrality values such as betweenness centrality.

\bibliographystyle{splncs04}
\bibliography{venice,self-loops}

\end{document}
